<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üîê Secure Fullstack App - E2EE</title>
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .main-content {
            padding: 30px;
        }

        .section {
            margin-bottom: 40px;
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        .section h2 {
            color: #2a5298;
            margin-bottom: 20px;
            font-size: 1.8em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }

        .input-group textarea {
            width: 100%;
            min-height: 100px;
            padding: 15px;
            border: 2px solid #e1e5e9;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: vertical;
            transition: border-color 0.3s;
        }

        .input-group textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin: 5px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn.success {
            background: linear-gradient(135deg, #56ab2f 0%, #a8e6cf 100%);
        }

        .btn.danger {
            background: linear-gradient(135deg, #ff416c 0%, #ff4b2b 100%);
        }

        .cards-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .card {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 20px;
            border-left: 5px solid #667eea;
            position: relative;
            overflow: hidden;
        }

        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #667eea, #764ba2);
        }

        .card h3 {
            color: #2a5298;
            margin-bottom: 15px;
            font-size: 1.3em;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .card-content {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #e1e5e9;
            max-height: 200px;
            overflow-y: auto;
            word-break: break-all;
        }

        .status {
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            font-weight: 600;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .log {
            background: #1e1e1e;
            color: #00ff00;
            padding: 15px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            max-height: 300px;
            overflow-y: auto;
            margin-top: 20px;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 5px 0;
        }

        .log-entry.timestamp {
            color: #888;
        }

        .log-entry.success {
            color: #00ff00;
        }

        .log-entry.error {
            color: #ff4444;
        }

        .log-entry.info {
            color: #4444ff;
        }

        .icon {
            font-size: 1.2em;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .flow-diagram {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 30px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 15px;
        }

        .flow-step {
            text-align: center;
            flex: 1;
        }

        .flow-step .icon {
            font-size: 2em;
            margin-bottom: 10px;
        }

        .flow-arrow {
            font-size: 1.5em;
            color: #667eea;
        }

        @media (max-width: 768px) {
            .cards-grid {
                grid-template-columns: 1fr;
            }
            
            .flow-diagram {
                flex-direction: column;
                gap: 20px;
            }
            
            .flow-arrow {
                transform: rotate(90deg);
            }
        }
    </style>
  </head>
  <body>
    <div class="container">
        <div class="header">
            <h1>üîê Secure Fullstack App</h1>
            <p>Military Grade End-to-End Encryption (E2EE) with ECC + AES-GCM + HMAC</p>
        </div>

        <div class="main-content">
            <!-- Handshake Section -->
            <div class="section">
                <h2><span class="icon">ü§ù</span>1. Secure Handshake (ECC Key Exchange)</h2>
                <div class="input-group">
                    <label>Client Message:</label>
                    <textarea id="clientMessage" placeholder="Enter your message here...">Hello from Client!</textarea>
                </div>
                <button class="btn" onclick="performHandshake()">üîë Perform Secure Handshake</button>
                <button class="btn success" onclick="testHandshake()">‚úÖ Test Handshake</button>
                
                <div class="cards-grid">
                    <div class="card">
                        <h3><span class="icon">üîë</span>Client ECC Key Pair</h3>
                        <div class="card-content" id="clientKeys">Not generated yet</div>
                    </div>
                    <div class="card">
                        <h3><span class="icon">üîê</span>Server ECC Public Key</h3>
                        <div class="card-content" id="serverPublicKey">Not received yet</div>
                    </div>
                    <div class="card">
                        <h3><span class="icon">üîó</span>Session Information</h3>
                        <div class="card-content" id="sessionInfo">No active session</div>
                    </div>
                </div>
            </div>

            <!-- Encryption Section -->
            <div class="section">
                <h2><span class="icon">üîí</span>2. Data Encryption Process</h2>
                <div class="flow-diagram">
                    <div class="flow-step">
                        <div class="icon">üìù</div>
                        <div>Original Data</div>
                    </div>
                    <div class="flow-arrow">‚Üí</div>
                    <div class="flow-step">
                        <div class="icon">üîê</div>
                        <div>AES-GCM Encryption</div>
                    </div>
                    <div class="flow-arrow">‚Üí</div>
                    <div class="flow-step">
                        <div class="icon">‚úçÔ∏è</div>
                        <div>HMAC Signature</div>
                    </div>
                    <div class="flow-arrow">‚Üí</div>
                    <div class="flow-step">
                        <div class="icon">üì¶</div>
                        <div>Encrypted Payload</div>
                    </div>
                </div>
                
                <button class="btn" onclick="encryptData()">üîí Encrypt & Send Data</button>
                <button class="btn" onclick="sendUserData()">üë§ Send User Data</button>
                <button class="btn" onclick="sendMessage()">üí¨ Send Message</button>
                
                <div class="cards-grid">
                    <div class="card">
                        <h3><span class="icon">üîê</span>AES-GCM Encrypted Data</h3>
                        <div class="card-content" id="aesEncrypted">Not encrypted yet</div>
                    </div>
                    <div class="card">
                        <h3><span class="icon">üîë</span>Session Key (Derived)</h3>
                        <div class="card-content" id="sessionKey">Not derived yet</div>
                    </div>
                    <div class="card">
                        <h3><span class="icon">‚úçÔ∏è</span>HMAC Signature</h3>
                        <div class="card-content" id="hmacSignature">Not signed yet</div>
                    </div>
                    <div class="card">
                        <h3><span class="icon">üì¶</span>Final Payload</h3>
                        <div class="card-content" id="finalPayload">Not prepared yet</div>
                    </div>
                </div>
            </div>

            <!-- Decryption Section -->
            <div class="section">
                <h2><span class="icon">üîì</span>3. Server Response & Decryption</h2>
                <div class="flow-diagram">
                    <div class="flow-step">
                        <div class="icon">üì¶</div>
                        <div>Server Response</div>
                    </div>
                    <div class="flow-arrow">‚Üí</div>
                    <div class="flow-step">
                        <div class="icon">üîç</div>
                        <div>HMAC Verification</div>
                    </div>
                    <div class="flow-arrow">‚Üí</div>
                    <div class="flow-step">
                        <div class="icon">üîì</div>
                        <div>AES-GCM Decryption</div>
                    </div>
                    <div class="flow-arrow">‚Üí</div>
                    <div class="flow-step">
                        <div class="icon">üìù</div>
                        <div>Decrypted Data</div>
                    </div>
                </div>
                
                <div class="cards-grid">
                    <div class="card">
                        <h3><span class="icon">üì¶</span>Server Response</h3>
                        <div class="card-content" id="serverResponse">No response yet</div>
                    </div>
                    <div class="card">
                        <h3><span class="icon">üîç</span>Signature Verification</h3>
                        <div class="card-content" id="signatureVerification">Not verified yet</div>
                    </div>
                    <div class="card">
                        <h3><span class="icon">üîì</span>Decrypted Message</h3>
                        <div class="card-content" id="decryptedMessage">Not decrypted yet</div>
                    </div>
                    <div class="card">
                        <h3><span class="icon">‚úÖ</span>Verification Status</h3>
                        <div class="card-content" id="verificationStatus">Not verified yet</div>
                    </div>
                </div>
            </div>

            <!-- Status and Logs -->
            <div class="section">
                <h2><span class="icon">üìä</span>4. System Status & Logs</h2>
                <div id="status" class="status info">System ready. Click "Perform Secure Handshake" to begin.</div>
                <div class="log" id="log"></div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let clientKeys = null;
        let sessionId = null;
        let serverPublicKey = null;
        let sessionKey = null;
        let isHandshakeComplete = false;

        // Utility functions
        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const timestamp = new Date().toISOString();
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${type}`;
            logEntry.innerHTML = `<span class="timestamp">[${timestamp}]</span> ${message}`;
            logDiv.appendChild(logEntry);
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function updateStatus(message, type = 'info') {
            const statusDiv = document.getElementById('status');
            statusDiv.className = `status ${type}`;
            statusDiv.textContent = message;
        }

        function updateCard(id, content) {
            const card = document.getElementById(id);
            if (card) {
                card.textContent = content;
            }
        }

        // Web Crypto API functions
        async function generateECCKeyPair() {
            try {
                const keyPair = await window.crypto.subtle.generateKey(
                    {
                        name: "ECDH",
                        namedCurve: "P-256"
                    },
                    true,
                    ["deriveKey", "deriveBits"]
                );
                return keyPair;
            } catch (error) {
                throw new Error(`Failed to generate ECC key pair: ${error.message}`);
            }
        }

        async function exportPublicKey(publicKey) {
            try {
                const exported = await window.crypto.subtle.exportKey("spki", publicKey);
                return btoa(String.fromCharCode(...new Uint8Array(exported)));
            } catch (error) {
                throw new Error(`Failed to export public key: ${error.message}`);
            }
        }

        async function importServerPublicKey(publicKeyB64) {
            try {
                const publicKeyBytes = Uint8Array.from(atob(publicKeyB64), c => c.charCodeAt(0));
                return await window.crypto.subtle.importKey(
                    "spki",
                    publicKeyBytes,
                    {
                        name: "ECDH",
                        namedCurve: "P-256"
                    },
                    true,
                    []
                );
            } catch (error) {
                throw new Error(`Failed to import server public key: ${error.message}`);
            }
        }

        async function deriveSessionKey(clientPrivateKey, serverPublicKey, sessionId) {
            try {
                const sharedSecret = await window.crypto.subtle.deriveBits(
                    {
                        name: "ECDH",
                        public: serverPublicKey
                    },
                    clientPrivateKey,
                    256
                );

                // Import shared secret as raw key for HKDF
                const sharedKey = await window.crypto.subtle.importKey(
                    "raw",
                    sharedSecret,
                    { name: "HKDF" },
                    false,
                    ["deriveKey"]
                );

                // Derive AES session key using HKDF
                const aesSessionKey = await window.crypto.subtle.deriveKey(
                    {
                        name: "HKDF",
                        salt: new TextEncoder().encode("secure_fullstack_app_salt"),
                        info: new TextEncoder().encode(sessionId + "_aes"),
                        hash: "SHA-256"
                    },
                    sharedKey,
                    { name: "AES-GCM", length: 256 },
                    false,
                    ["encrypt", "decrypt"]
                );

                // Derive HMAC key using HKDF
                const hmacKey = await window.crypto.subtle.deriveKey(
                    {
                        name: "HKDF",
                        salt: new TextEncoder().encode("secure_fullstack_app_salt"),
                        info: new TextEncoder().encode(sessionId + "_hmac"),
                        hash: "SHA-256"
                    },
                    sharedKey,
                    { name: "HMAC", hash: "SHA-256" },
                    false,
                    ["sign", "verify"]
                );

                return { aesKey: aesSessionKey, hmacKey: hmacKey };
            } catch (error) {
                throw new Error(`Failed to derive session key: ${error.message}`);
            }
        }

        async function encryptDataWithKeys(data, sessionKeys) {
            try {
                const iv = window.crypto.getRandomValues(new Uint8Array(12));
                const encodedData = new TextEncoder().encode(JSON.stringify(data));
                
                // Encrypt data with AES-GCM
                const encryptedData = await window.crypto.subtle.encrypt(
                    { name: "AES-GCM", iv: iv },
                    sessionKeys.aesKey,
                    encodedData
                );
                const encryptedBytes = new Uint8Array(encryptedData);
                const ciphertext = encryptedBytes.slice(0, -16);
                const tag = encryptedBytes.slice(-16);

                // HMAC over binary concatenation (iv + tag + ciphertext)
                const signatureData = new Uint8Array([
                    ...iv,
                    ...tag,
                    ...ciphertext
                ]);
                const signature = await window.crypto.subtle.sign(
                    { name: "HMAC", hash: "SHA-256" },
                    sessionKeys.hmacKey,
                    signatureData
                );

                // Prepare payload
                const finalPayload = {
                    encrypted_data: {
                        payload: btoa(String.fromCharCode(...ciphertext)),
                        iv: btoa(String.fromCharCode(...iv)),
                        tag: btoa(String.fromCharCode(...tag)),
                        signature: btoa(String.fromCharCode(...new Uint8Array(signature)))
                    }
                };
                
                return finalPayload;
            } catch (error) {
                throw new Error(`Failed to encrypt data: ${error.message}`);
            }
        }

        async function createSignature(data, sessionKeys) {
            try {
                const signature = await window.crypto.subtle.sign(
                    {
                        name: "HMAC",
                        hash: "SHA-256"
                    },
                    sessionKeys.hmacKey,
                    new TextEncoder().encode(data)
                );
                return btoa(String.fromCharCode(...new Uint8Array(signature)));
            } catch (error) {
                throw new Error(`Failed to create signature: ${error.message}`);
            }
        }

        async function decryptResponse(encryptedData, iv, sessionKeys) {
            try {
                const encryptedBytes = Uint8Array.from(atob(encryptedData), c => c.charCodeAt(0));
                const ivBytes = Uint8Array.from(atob(iv), c => c.charCodeAt(0));
                
                const decryptedData = await window.crypto.subtle.decrypt(
                    {
                        name: "AES-GCM",
                        iv: ivBytes
                    },
                    sessionKeys.aesKey,
                    encryptedBytes
                );

                return JSON.parse(new TextDecoder().decode(decryptedData));
            } catch (error) {
                throw new Error(`Failed to decrypt response: ${error.message}`);
            }
        }

        async function verifySignature(data, signature, sessionKeys) {
            try {
                const signatureBytes = Uint8Array.from(atob(signature), c => c.charCodeAt(0));
                const isValid = await window.crypto.subtle.verify(
                    {
                        name: "HMAC",
                        hash: "SHA-256"
                    },
                    sessionKeys.hmacKey,
                    signatureBytes,
                    new TextEncoder().encode(data)
                );
                return isValid;
            } catch (error) {
                throw new Error(`Failed to verify signature: ${error.message}`);
            }
        }

        // API functions
        async function performHandshake() {
            try {
                updateStatus("üîÑ Performing secure handshake...", "info");
                log("Starting secure handshake process...", "info");

                // Generate client ECC key pair
                log("Generating client ECC key pair...", "info");
                clientKeys = await generateECCKeyPair();
                const clientPublicKeyB64 = await exportPublicKey(clientKeys.publicKey);
                
                updateCard('clientKeys', `Public Key: ${clientPublicKeyB64.substring(0, 50)}...\nPrivate Key: [SECURE]`);
                log("Client ECC key pair generated successfully", "success");

                // Send handshake request
                log("Sending handshake request to server...", "info");
                const response = await fetch('http://localhost:8000/api/v1/handshake', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        client_public_key: clientPublicKeyB64
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const handshakeResponse = await response.json();
                sessionId = handshakeResponse.session_id;
                localStorage.setItem("session_id", sessionId); // <-- Store session_id for future requests
                serverPublicKey = handshakeResponse.server_public_key;
                
                updateCard('serverPublicKey', `Server Public Key: ${serverPublicKey.substring(0, 50)}...`);
                updateCard('sessionInfo', `Session ID: ${sessionId}\nStatus: Active\nExpires: 24 hours`);
                log("Handshake completed successfully", "success");

                // Import server public key and derive session key
                log("Importing server public key...", "info");
                const importedServerPublicKey = await importServerPublicKey(serverPublicKey);
                
                log("Deriving session keys...", "info");
                sessionKey = await deriveSessionKey(clientKeys.privateKey, importedServerPublicKey, sessionId);
                
                updateCard('sessionKey', `AES Key: [DERIVED SECURELY]\nHMAC Key: [DERIVED SECURELY]\nAlgorithm: AES-GCM-256 + HMAC-SHA256\nSource: ECDH + HKDF`);
                log("Session key derived successfully", "success");

                isHandshakeComplete = true;
                updateStatus("‚úÖ Handshake completed successfully! Ready for encrypted communication.", "success");
                log("System ready for encrypted communication", "success");

            } catch (error) {
                log(`Handshake failed: ${error.message}`, "error");
                updateStatus(`‚ùå Handshake failed: ${error.message}`, "error");
            }
        }

        // Utility: get sessionId safely
        function getSessionId() {
            // Prefer in-memory, fallback to localStorage
            return sessionId || localStorage.getItem("session_id");
        }

        async function encryptData() {
            if (!isHandshakeComplete) {
                updateStatus("‚ùå Please perform handshake first", "error");
                return;
            }

            const currentSessionId = getSessionId();
            if (!currentSessionId) {
                log("No session ID found. Please perform handshake.", "error");
                updateStatus("‚ùå No session ID found. Please perform handshake.", "error");
                return;
            }

            try {
                updateStatus("üîí Encrypting data...", "info");
                log("Starting data encryption process...", "info");

                const message = document.getElementById('clientMessage').value;
                const data = { message: message, timestamp: new Date().toISOString() };

                // Encrypt data with AES-GCM
                log("Encrypting data with AES-GCM...", "info");
                const encrypted = await encryptDataWithKeys(data, sessionKey);
                
                updateCard('aesEncrypted', `Encrypted Data: ${encrypted.encrypted_data.payload.substring(0, 100)}...\nIV: ${encrypted.encrypted_data.iv}`);
                log("Data encrypted with AES-GCM successfully", "success");

                // HMAC signature already correct in encrypted.encrypted_data.signature
                updateCard('hmacSignature', `Signature: ${encrypted.encrypted_data.signature.substring(0, 100)}...\nAlgorithm: HMAC-SHA256`);
                log("HMAC signature created successfully", "success");

                // Prepare final payload
                const finalPayload = encrypted;
                
                updateCard('finalPayload', `Final Payload:\n${JSON.stringify(finalPayload, null, 2)}`);
                log("Final payload prepared", "success");

                // Send encrypted data
                log("Sending encrypted data to server...", "info");
                let response;
                try {
                    response = await fetch('http://localhost:8000/api/v1/secure/data', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Session-ID': currentSessionId
                        },
                        body: JSON.stringify(finalPayload)
                    });
                    if (response.status === 401 || response.status === 500) {
                        // Session might be invalid, try handshake and retry once
                        log("Session invalid or expired. Performing handshake and retrying...", "warn");
                        await performHandshake();
                        currentSessionId = getSessionId();
                        response = await fetch('http://localhost:8000/api/v1/secure/data', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-Session-ID': currentSessionId
                            },
                            body: JSON.stringify(finalPayload)
                        });
                    }
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                } catch (error) {
                    log(`Secure data request failed: ${error.message}`, "error");
                    updateStatus(`‚ùå Secure data request failed: ${error.message}`, "error");
                    return;
                }

                const responseData = await response.json();
                updateCard('serverResponse', `Server Response:\n${JSON.stringify(responseData, null, 2)}`);
                log("Server response received", "success");

                // Decrypt and verify response
                log("Decrypting server response...", "info");
                const decryptedResponse = await decryptResponse(
                    responseData.encrypted_data.payload,
                    responseData.encrypted_data.iv,
                    sessionKey
                );
                
                updateCard('decryptedMessage', `Decrypted Message:\n${JSON.stringify(decryptedResponse, null, 2)}`);
                log("Response decrypted successfully", "success");

                // Verify signature
                log("Verifying response signature...", "info");
                const signatureData2 = new Uint8Array([
                    ...Uint8Array.from(atob(responseData.encrypted_data.iv), c => c.charCodeAt(0)),
                    ...Uint8Array.from(atob(responseData.encrypted_data.tag), c => c.charCodeAt(0)),
                    ...Uint8Array.from(atob(responseData.encrypted_data.payload), c => c.charCodeAt(0))
                ]);
                const isValid = await window.crypto.subtle.verify(
                    { name: "HMAC", hash: "SHA-256" },
                    sessionKey.hmacKey,
                    Uint8Array.from(atob(responseData.encrypted_data.signature), c => c.charCodeAt(0)),
                    signatureData2
                );
                
                updateCard('signatureVerification', `Signature Valid: ${isValid}\nAlgorithm: HMAC-SHA256`);
                updateCard('verificationStatus', isValid ? "‚úÖ Signature Verified" : "‚ùå Signature Invalid");
                
                if (isValid) {
                    log("Response signature verified successfully", "success");
                    updateStatus("‚úÖ Data transmission completed successfully!", "success");
                } else {
                    log("Response signature verification failed", "error");
                    updateStatus("‚ùå Response signature verification failed", "error");
                }

            } catch (error) {
                log(`Encryption test failed: ${error.message}`, "error");
                updateStatus(`‚ùå Encryption test failed: ${error.message}`, "error");
            }
        }

        async function sendUserData() {
            if (!isHandshakeComplete) {
                updateStatus("‚ùå Please perform handshake first", "error");
                return;
            }

            const currentSessionId = getSessionId();
            if (!currentSessionId) {
                log("No session ID found. Please perform handshake.", "error");
                updateStatus("‚ùå No session ID found. Please perform handshake.", "error");
                return;
            }

            try {
                updateStatus("üë§ Sending encrypted user data...", "info");
                log("Starting user data transmission...", "info");

                const userData = {
                    user_id: "user_123",
                    username: "secure_user",
                    email: "user@secureapp.com",
                    timestamp: new Date().toISOString()
                };

                const encrypted = await encryptDataWithKeys(userData, sessionKey);

                // No need to re-sign, signature already correct in encrypted.encrypted_data.signature
                const payload = encrypted;

                const response = await fetch('http://localhost:8000/api/v1/secure/user', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Session-ID': currentSessionId
                    },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const responseData = await response.json();
                const decryptedResponse = await decryptResponse(
                    responseData.encrypted_data.payload,
                    responseData.encrypted_data.iv,
                    sessionKey
                );

                updateCard('decryptedMessage', `User Data Response:\n${JSON.stringify(decryptedResponse, null, 2)}`);
                log("User data transmission completed", "success");
                updateStatus("‚úÖ User data transmission completed successfully!", "success");

            } catch (error) {
                log(`User data test failed: ${error.message}`, "error");
                updateStatus(`‚ùå User data test failed: ${error.message}`, "error");
            }
        }

        async function sendMessage() {
            if (!isHandshakeComplete) {
                updateStatus("‚ùå Please perform handshake first", "error");
                return;
            }

            const currentSessionId = getSessionId();
            if (!currentSessionId) {
                log("No session ID found. Please perform handshake.", "error");
                updateStatus("‚ùå No session ID found. Please perform handshake.", "error");
                return;
            }

            try {
                updateStatus("üí¨ Sending encrypted message...", "info");
                log("Starting message transmission...", "info");

                const messageData = {
                    message_id: "msg_" + Date.now(),
                    content: document.getElementById('clientMessage').value,
                    sender: "client",
                    timestamp: new Date().toISOString()
                };

                const encrypted = await encryptDataWithKeys(messageData, sessionKey);

                // No need to re-sign, signature already correct in encrypted.encrypted_data.signature
                const payload = encrypted;

                const response = await fetch('http://localhost:8000/api/v1/secure/message', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Session-ID': currentSessionId
                    },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const responseData = await response.json();
                const decryptedResponse = await decryptResponse(
                    responseData.encrypted_data.payload,
                    responseData.encrypted_data.iv,
                    sessionKey
                );

                updateCard('decryptedMessage', `Message Response:\n${JSON.stringify(decryptedResponse, null, 2)}`);
                log("Message transmission completed", "success");
                updateStatus("‚úÖ Message transmission completed successfully!", "success");

            } catch (error) {
                log(`Message test failed: ${error.message}`, "error");
                updateStatus(`‚ùå Message test failed: ${error.message}`, "error");
            }
        }

        async function testHandshake() {
            try {
                updateStatus("üß™ Testing handshake...", "info");
                log("Testing handshake functionality...", "info");

                const response = await fetch('http://localhost:8000/api/v1/health');
                if (response.ok) {
                    log("Backend health check passed", "success");
                    updateStatus("‚úÖ Backend is healthy and ready", "success");
                } else {
                    throw new Error("Backend health check failed");
                }
            } catch (error) {
                log(`Handshake test failed: ${error.message}`, "error");
                updateStatus(`‚ùå Handshake test failed: ${error.message}`, "error");
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            log("Secure Fullstack App initialized", "info");
            log("Ready to perform military-grade E2EE communication", "info");
        });
    </script>
  </body>
</html>

